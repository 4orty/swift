// This package provides an easy to use interface to Swift / Openstack
// Object Storage / Rackspace cloud files from the Go Language
package swift

/*
FIXME need to implement the fixed errors so can distinguish not found etc

FIXME return body close errors

FIXME rename to go-swift to match user agent string

FIXME reconnect on auth error - 403 when token expires

FIXME implement read all files / containers which uses limit and marker to loop

FIXME make more api compatible with python cloudfiles?

FIXME timeout?

Retry operations on timeout / network errors?

FIXME put USER_AGENT and RETRIES into Connection

Make Connection thread safe - whenever it is changed take a write lock whenever it is read from a read lock

Add extra headers field to Connection (for via etc)

Could potentially store response in Connection but would make it thread unsafe

Make errors use an error heirachy then can catch them with a type assertion

 Error(...)
 ObjectCorrupted{ Error }

Make a Debug flag for logging stuff

Object metadata with HEAD and POST and PUT

Object If-Match, If-None-Match, If-Modified-Since, If-Unmodified-Since etc

Object range

Object create, update with X-Delete-At or X-Delete-After

Large object support
- check uploads are less than 5GB in normal mode?

Access control CORS?

Copy object

Perhaps allow extra headers on the basic operations?

Or re-work the metadata so it is just extra http headers with some utility functions to set metadata?

FIXME swift client retries and backs off for all types of errors

FIXME write a script which uses this and replicates the functionality of swift tool

FIXME add unit tests

*/

import (
	"bufio"
	"bytes"
	"crypto/md5"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

const (
	USER_AGENT      = "goswift/1.0" // Default user agent
	DEFAULT_RETRIES = 3             // Default number of retries on token expiry
)

// Connection holds the details of the connection to the swift server
//
// You need to provide UserName, ApiKey and AuthUrl when you create a
// connection then call Authenticate on it.
// 
// For reference some common AuthUrls looks like this:
//
//  Rackspace US        https://auth.api.rackspacecloud.com/v1.0
//  Rackspace UK        https://lon.auth.api.rackspacecloud.com/v1.0
//  Memset Memstore UK  https://auth.storage.memset.com/v1.0
type Connection struct {
	UserName    string
	ApiKey      string
	AuthUrl     string
	storage_url string
	auth_token  string
	tr          *http.Transport
	client      *http.Client
}

// All errors generated by this package are of this type.  Other error
// may be passed on from library functions though.
type Error struct {
	StatusCode int // HTTP status code if relevant or 0 if not
	Text       string
}

// Satisfy the error interface
func (e *Error) Error() string {
	return e.Text
}

// Make a new error from a string
func newError(StatusCode int, Text string) *Error {
	return &Error{
		StatusCode: StatusCode,
		Text:       Text,
	}
}

// Make a new error from sprintf parameters
func newErrorf(StatusCode int, Text string, Parameters ...interface{}) *Error {
	return newError(StatusCode, fmt.Sprintf(Text, Parameters...))
}

type errorMap map[int]error

var (
	// Specific Errors you might want to check for equality
	AuthorizationFailed = newError(401, "Authorization Failed")
	ContainerNotFound   = newError(404, "Container Not Found")
	ContainerNotEmpty   = newError(409, "Container Not Empty")
	ObjectNotFound      = newError(404, "Object Not Found")
	ObjectCorrupted     = newError(422, "Object Corrupted")

	// Mappings for authentication errors
	authErrorMap = errorMap{
		401: AuthorizationFailed,
	}

	// Mappings for container errors
	containerErrorMap = errorMap{
		404: ContainerNotFound,
		409: ContainerNotEmpty,
	}

	// Mappings for object errors
	objectErrorMap = errorMap{
		404: ObjectNotFound,
		422: ObjectCorrupted,
	}
)

// Utility function used to check the return from Close in a defer
// statement
func checkClose(c io.Closer, err *error) {
	cerr := c.Close()
	if *err == nil {
		*err = cerr
	}
}

// Check a response for errors and translate into standard errors if necessary
func (c *Connection) parseHeaders(resp *http.Response, errorMap errorMap) error {
	if errorMap != nil {
		if err, ok := errorMap[resp.StatusCode]; ok {
			return err
		}
	}
	// FIXME convert date header here?
	if resp.StatusCode < 200 || resp.StatusCode > 299 {
		return newErrorf(resp.StatusCode, "HTTP Error: %d: %s", resp.StatusCode, resp.Status)
	}
	return nil
}

// Returns a Headers object from the http.Response
//
// Logs a warning if receives multiple values for a key (which
// should never happen)
func readHeaders(resp *http.Response) Headers {
	headers := Headers{}
	for key, values := range resp.Header {
		headers[key] = values[0]
		if len(values) > 1 {
			log.Printf("swift: received multiple values for header %q", key)
		}
	}
	return headers
}

// Type for storing HTTP headers (can only have one of each header like swift)
type Headers map[string]string

// Type for storing metadata
type Metadata map[string]string

// Metadata gets the Metadata starting with the metaPrefix out of the Headers
//
// The keys in the Metadata will be converted to lower case
func (h Headers) Metadata(metaPrefix string) Metadata {
	m := Metadata{}
	metaPrefix = http.CanonicalHeaderKey(metaPrefix)
	for key, value := range h {
		if strings.HasPrefix(key, metaPrefix) {
			metaKey := strings.ToLower(key[len(metaPrefix):])
			m[metaKey] = value
		}
	}
	return m
}

// AccountMetadata converts Headers from account to a Metadata
//
// The keys in the Metadata will be converted to lower case
func (h Headers) AccountMetadata() Metadata {
	return h.Metadata("X-Account-Meta-")
}

// ContainerMetadata converts Headers from container to a Metadata
//
// The keys in the Metadata will be converted to lower case
func (h Headers) ContainerMetadata() Metadata {
	return h.Metadata("X-Container-Meta-")
}

// ObjectMetadata converts Headers from object to a Metadata
//
// The keys in the Metadata will be converted to lower case
func (h Headers) ObjectMetadata() Metadata {
	return h.Metadata("X-Object-Meta-")
}

// Headers convert the Metadata starting with the metaPrefix into a Headers
//
// The keys in the Metadata will be converted from lower case to http Canonical (see http.CanonicalHeaderKey)
func (m Metadata) Headers(metaPrefix string) Headers {
	h := Headers{}
	for key, value := range m {
		key = http.CanonicalHeaderKey(metaPrefix + key)
		h[key] = value
	}
	return h
}

// AccountHeaders converts the Metadata for the account
func (m Metadata) AccountHeaders() Headers {
	return m.Headers("X-Account-Meta-")
}

// ContainerHeaders converts the Metadata for the container
func (m Metadata) ContainerHeaders() Headers {
	return m.Headers("X-Container-Meta-")
}

// ObjectHeaders converts the Metadata for the object
func (m Metadata) ObjectHeaders() Headers {
	return m.Headers("X-Object-Meta-")
}

// Connects to the cloud storage system
func (c *Connection) Authenticate() (err error) {
	if c.tr == nil {
		c.tr = &http.Transport{
		//		TLSClientConfig:    &tls.Config{RootCAs: pool},
		//		DisableCompression: true,
		}
	}
	if c.client == nil {
		c.client = &http.Client{
			//		CheckRedirect: redirectPolicyFunc,
			Transport: c.tr,
		}
	}
	// Flush the keepalives connection - if we are
	// re-authenticating then stuff has gone wrong
	c.tr.CloseIdleConnections()
	var req *http.Request
	req, err = http.NewRequest("GET", c.AuthUrl, nil)
	if err != nil {
		return
	}
	req.Header.Set("User-Agent", USER_AGENT)
	req.Header.Set("X-Auth-Key", c.ApiKey)
	req.Header.Set("X-Auth-User", c.UserName)
	var resp *http.Response
	resp, err = c.client.Do(req)
	if err != nil {
		return
	}
	defer func() {
		checkClose(resp.Body, &err)
		// Flush the auth connection - we don't want to keep
		// it open if keepalives were enabled
		c.tr.CloseIdleConnections()
	}()
	if err = c.parseHeaders(resp, authErrorMap); err != nil {
		return
	}
	c.storage_url = resp.Header.Get("X-Storage-Url")
	c.auth_token = resp.Header.Get("X-Auth-Token")
	if !c.Authenticated() {
		return newError(0, "Response didn't have storage url and auth token")
	}
	return nil
}

// Removes the authentication
func (c *Connection) UnAuthenticate() {
	c.storage_url = ""
	c.auth_token = ""
}

// A boolean to show if the current connection is authenticated
//
// Doesn't actually check the credentials
func (c *Connection) Authenticated() bool {
	return c.storage_url != "" && c.auth_token != ""
}

// Parameters for Connection.storage
type storageParams struct {
	container   string
	object_name string
	operation   string
	parameters  url.Values
	headers     Headers
	errorMap    errorMap
	noResponse  bool
	body        io.Reader
	retries     int
}

// Run a remote command on a the storage url, returns a deferred to receive the result
// operation is GET, HEAD etc
// container is the name of a container
// Any other parameters (if not None) are added to the storage url
//
// Returns a response or an error.  If response is returned then
// resp.Body.Close() must be called on it, unless noResponse is set in
// which case the body will be closed in this function
//
// FIXME make noResponse check for 204?
//
// This will Authenticate if necessary, and re-authenticate if it
// receives a 401 error which means the token has expired
func (c *Connection) storage(p storageParams) (resp *http.Response, headers Headers, err error) {
	retries := p.retries
	if retries == 0 {
		retries = DEFAULT_RETRIES
	}
	for {
		if !c.Authenticated() {
			err = c.Authenticate()
			if err != nil {
				return
			}
		}
		url := c.storage_url
		if p.container != "" {
			url += "/" + p.container
			if p.object_name != "" {
				url += "/" + p.object_name
			}
		}
		if p.parameters != nil {
			encoded := p.parameters.Encode()
			if encoded != "" {
				url += "?" + encoded
			}
		}
		var req *http.Request
		req, err = http.NewRequest(p.operation, url, p.body)
		if err != nil {
			return
		}
		if p.headers != nil {
			for k, v := range p.headers {
				req.Header.Add(k, v)
			}
		}
		req.Header.Add("User-Agent", USER_AGENT)
		req.Header.Add("X-Auth-Token", c.auth_token)
		// FIXME body of request?
		resp, err = c.client.Do(req)
		if err != nil {
			return
		}
		// Check to see if token has expired
		if resp.StatusCode == 401 && retries > 0 {
			_ = resp.Body.Close()
			c.UnAuthenticate()
			retries--
		} else {
			break
		}
	}

	if err = c.parseHeaders(resp, p.errorMap); err != nil {
		_ = resp.Body.Close()
		return nil, nil, err
	}
	headers = readHeaders(resp)
	if p.noResponse {
		err = resp.Body.Close()
		if err != nil {
			return nil, nil, err
		}
	}
	return
}

// Read the response into an array of strings
//
// Closes the response when done
func readLines(resp *http.Response) (lines []string, err error) {
	defer checkClose(resp.Body, &err)
	reader := bufio.NewReader(resp.Body)
	buffer := bytes.NewBuffer(make([]byte, 128))
	var part []byte
	var prefix bool
	for {
		if part, prefix, err = reader.ReadLine(); err != nil {
			break
		}
		buffer.Write(part)
		if !prefix {
			lines = append(lines, buffer.String())
			buffer.Reset()
		}
	}
	if err == io.EOF {
		err = nil
	}
	return
}

// Read the response into the json type passed in
//
// Closes the response when done
func readJson(resp *http.Response, result interface{}) (err error) {
	defer checkClose(resp.Body, &err)
	decoder := json.NewDecoder(resp.Body)
	return decoder.Decode(result)
}

/* ------------------------------------------------------------ */

// Options for ListContainers*
type ListContainersOpts struct {
	Limit   int     // For an integer value n, limits the number of results to at most n values.
	Marker  string  // Given a string value x, return object names greater in value than the specified marker.
	Headers Headers // Any additional HTTP headers - can be nil
}

func (opts *ListContainersOpts) parse() (url.Values, Headers) {
	v := url.Values{}
	var h Headers
	if opts != nil {
		if opts.Limit > 0 {
			v.Set("limit", strconv.Itoa(opts.Limit))
		}
		if opts.Marker != "" {
			v.Set("marker", opts.Marker)
		}
		h = opts.Headers
	}
	return v, h
}

// Return a list of names of containers in this account
func (c *Connection) ListContainers(opts *ListContainersOpts, h Headers) ([]string, Headers, error) {
	v, h := opts.parse()
	resp, headers, err := c.storage(storageParams{
		operation:  "GET",
		parameters: v,
		errorMap:   containerErrorMap,
		headers:    h,
	})
	if err != nil {
		return nil, nil, err
	}
	lines, err := readLines(resp)
	return lines, headers, err
}

// Information about a container
type ContainerInfo struct {
	Name  string // Name of the container
	Count int64  // Number of objects in the container
	Bytes int64  // Total number of bytes used in the container
}

// Return a list of structures with full information as described in ContainerInfo
func (c *Connection) ListContainersInfo(opts *ListContainersOpts) ([]ContainerInfo, Headers, error) {
	v, h := opts.parse()
	v.Set("format", "json")
	resp, headers, err := c.storage(storageParams{
		operation:  "GET",
		parameters: v,
		errorMap:   containerErrorMap,
		headers:    h,
	})
	if err != nil {
		return nil, nil, err
	}
	var containers []ContainerInfo
	err = readJson(resp, &containers)
	return containers, headers, err
}

/* ------------------------------------------------------------ */

// Options for ListObjects*
type ListObjectsOpts struct {
	Limit     int     // For an integer value n, limits the number of results to at most n values.
	Marker    string  // Given a string value x, return object names greater in value than the  specified marker.
	EndMarker string  // Given a string value x, return object names less in value than the specified marker
	Prefix    string  // For a string value x, causes the results to be limited to object names beginning with the substring x.
	Path      string  // For a string value x, return the object names nested in the pseudo path
	Delimiter rune    // For a character c, return all the object names nested in the container
	Headers   Headers // Any additional HTTP headers - can be nil
}

func (opts *ListObjectsOpts) parse() (url.Values, Headers) {
	v := url.Values{}
	var h Headers
	if opts != nil {
		if opts.Limit > 0 {
			v.Set("limit", strconv.Itoa(opts.Limit))
		}
		if opts.Marker != "" {
			v.Set("marker", opts.Marker)
		}
		if opts.EndMarker != "" {
			v.Set("end_marker", opts.EndMarker)
		}
		if opts.Prefix != "" {
			v.Set("prefix", opts.Prefix)
		}
		if opts.Path != "" {
			v.Set("path", opts.Path)
		}
		if opts.Delimiter != 0 {
			v.Set("delimiter", string(opts.Delimiter))
		}
		h = opts.Headers
	}
	return v, h
}

// Return a list of names of objects in a given container
func (c *Connection) ListObjects(container string, opts *ListObjectsOpts) ([]string, Headers, error) {
	v, h := opts.parse()
	resp, headers, err := c.storage(storageParams{
		container:  container,
		operation:  "GET",
		parameters: v,
		errorMap:   containerErrorMap,
		headers:    h,
	})
	if err != nil {
		return nil, nil, err
	}
	lines, err := readLines(resp)
	return lines, headers, err
}

// Information about an object
type ObjectInfo struct {
	Name            string `json:"name"`          // object name
	ContentType     string `json:"content_type"`  // eg application/directory
	Bytes           int64  `json:"bytes"`         // size in bytes
	LastModified    string `json:"last_modified"` // Last modified time, eg '2011-06-30T08:20:47.736680'
	Hash            string `json:"hash"`          // MD5 hash, eg "d41d8cd98f00b204e9800998ecf8427e"
	PseudoDirectory bool   // Set when using delimiter to show that this directory object does not really exist
	SubDir          string `json:"subdir"` // returned only when using delimiter to mark "pseudo directories"
}

// Return ObjectInfos with information about each object in the container
//
// If Delimiter is set in the opts then PseudoDirectory may be set,
// with ContentType 'application/directory'.  These are not real
// objects but represent directories of objects which haven't had an
// object created for them.
func (c *Connection) ListObjectsInfo(container string, opts *ListObjectsOpts) ([]ObjectInfo, Headers, error) {
	v, h := opts.parse()
	v.Set("format", "json")
	resp, headers, err := c.storage(storageParams{
		container:  container,
		operation:  "GET",
		parameters: v,
		errorMap:   containerErrorMap,
		headers:    h,
	})
	if err != nil {
		return nil, nil, err
	}
	var containers []ObjectInfo
	err = readJson(resp, &containers)
	for i := range containers {
		if containers[i].SubDir != "" {
			containers[i].Name = containers[i].SubDir
			containers[i].PseudoDirectory = true
			containers[i].ContentType = "application/directory"
		}
	}
	// FIXME convert the dates!
	return containers, headers, err
}

// Information about this account
type AccountInfo struct {
	BytesUsed  int64 // total number of bytes used
	Containers int64 // total number of containers
	Objects    int64 // total number of objects
}

// Helper function to decode int64 from header
func getInt64FromHeader(resp *http.Response, header string) (result int64, err error) {
	value := resp.Header.Get(header)
	result, err = strconv.ParseInt(value, 10, 64)
	if err != nil {
		err = newErrorf(0, "Bad Header '%s': '%s': %s", header, value, err)
	}
	return
}

// Return info about the account in an AccountInfo struct
func (c *Connection) AccountInfo(h Headers) (info AccountInfo, headers Headers, err error) {
	var resp *http.Response
	resp, headers, err = c.storage(storageParams{
		operation:  "HEAD",
		errorMap:   containerErrorMap,
		noResponse: true,
		headers:    h,
	})
	if err != nil {
		return
	}
	// Parse the headers into a dict
	//
	//    {'Accept-Ranges': 'bytes',
	//     'Content-Length': '0',
	//     'Date': 'Tue, 05 Jul 2011 16:37:06 GMT',
	//     'X-Account-Bytes-Used': '316598182',
	//     'X-Account-Container-Count': '4',
	//     'X-Account-Object-Count': '1433'}
	if info.BytesUsed, err = getInt64FromHeader(resp, "X-Account-Bytes-Used"); err != nil {
		return
	}
	if info.Containers, err = getInt64FromHeader(resp, "X-Account-Container-Count"); err != nil {
		return
	}
	if info.Objects, err = getInt64FromHeader(resp, "X-Account-Object-Count"); err != nil {
		return
	}
	return
}

// Add, Replace or Remove Account Metadata
//
// Add or Update keys by mentioning them in the Headers
//
// Remove keys by setting them to an empty string
func (c *Connection) UpdateAccount(h Headers) (Headers, error) {
	_, headers, err := c.storage(storageParams{
		operation:  "POST",
		errorMap:   containerErrorMap,
		noResponse: true,
		headers:    h,
	})
	return headers, err
}

// FIXME Make a container struct so these could be methods on it?

// Create a container.
//
// If you don't want to add Metadata just pass in nil
//
// No error is returned if it already exists.
func (c *Connection) CreateContainer(container string, h Headers) (Headers, error) {
	_, headers, err := c.storage(storageParams{
		container:  container,
		operation:  "PUT",
		errorMap:   containerErrorMap,
		noResponse: true,
		headers:    h,
	})
	return headers, err
}

// Delete a container.
// May return ContainerDoesNotExist or ContainerNotEmpty
func (c *Connection) DeleteContainer(container string, h Headers) (Headers, error) {
	_, headers, err := c.storage(storageParams{
		container:  container,
		operation:  "DELETE",
		errorMap:   containerErrorMap,
		noResponse: true,
		headers:    h,
	})
	return headers, err
}

// Returns info about a single container
func (c *Connection) ContainerInfo(container string, h Headers) (info ContainerInfo, headers Headers, err error) {
	var resp *http.Response
	resp, headers, err = c.storage(storageParams{
		container:  container,
		operation:  "HEAD",
		errorMap:   containerErrorMap,
		noResponse: true,
		headers:    h,
	})
	if err != nil {
		return
	}
	// FIXME wordy
	// Parse the headers into the struct
	info.Name = container
	if info.Bytes, err = getInt64FromHeader(resp, "X-Container-Bytes-Used"); err != nil {
		return
	}
	if info.Count, err = getInt64FromHeader(resp, "X-Container-Object-Count"); err != nil {
		return
	}
	return
}

// Add, Replace or Remove Container Metadata
//
// Add or Update keys by mentioning them in the Metadata
//
// Remove keys by setting them to an empty string
//
// Container metadata can only be read with ContainerInfo not with any
// of the ListContainer methods.
func (c *Connection) UpdateContainer(container string, h Headers) (Headers, error) {
	_, headers, err := c.storage(storageParams{
		container:  container,
		operation:  "POST",
		errorMap:   containerErrorMap,
		noResponse: true,
		headers:    h,
	})
	return headers, err
}

// ------------------------------------------------------------

// Create or update the path in the container from contents.
// contents should be an open io.Reader which will have all its contents read
// 
// If checkMd5 is True then it will calculate the md5sum of the
// file as it is being uploaded and check it against that
// returned from the server.  If it is wrong then it will raise ObjectCorrupted
// 
// If md5 is set the it will be sent to the server which will
// check the md5 itself after the upload, and will raise
// ObjectCorrupted if it is incorrect.
// 
// If contentType is set it will be used, otherwise one will be
// guessed from the name using the mimetypes module FIXME
//
// FIXME I think this will do chunked transfer since we aren't providing a content length
func (c *Connection) CreateObject(container string, objectName string, contents io.Reader, checkMd5 bool, Md5 string, contentType string, h Headers) (headers Headers, err error) {
	if contentType == "" {
		// http.DetectContentType FIXME
		contentType = "application/octet-stream" // FIXME
	}
	// Meta stuff
	extra_headers := map[string]string{
		"Content-Type": contentType,
	}
	for key, value := range h {
		extra_headers[key] = value
	}
	if Md5 != "" {
		extra_headers["Etag"] = Md5
		checkMd5 = false // the server will do it
	}
	hash := md5.New()
	var body io.Reader = contents
	if checkMd5 {
		body = io.TeeReader(contents, hash)
	}
	var resp *http.Response
	resp, headers, err = c.storage(storageParams{
		container:   container,
		object_name: objectName,
		operation:   "PUT",
		headers:     extra_headers,
		body:        body,
		noResponse:  true,
		errorMap:    objectErrorMap,
	})
	if err != nil {
		return
	}
	if checkMd5 {
		md5 := strings.ToLower(resp.Header.Get("Etag"))
		body_md5 := fmt.Sprintf("%x", hash.Sum(nil))
		if md5 != body_md5 {
			err = ObjectCorrupted
			return
		}
	}
	return
}

// Create an object from a []byte in a container
// This is a simplified interface which checks the MD5
func (c *Connection) CreateObjectBytes(container string, objectName string, contents []byte, contentType string) (err error) {
	buf := bytes.NewBuffer(contents)
	_, err = c.CreateObject(container, objectName, buf, true, "", contentType, nil)
	return
}

// Create an object from a string in a container
// This is a simplified interface which checks the MD5
func (c *Connection) CreateObjectString(container string, objectName string, contents string, contentType string) (err error) {
	buf := strings.NewReader(contents)
	_, err = c.CreateObject(container, objectName, buf, true, "", contentType, nil)
	return
}

// Get the object into the io.Writer contents
// 
// Returns the headers of the response
// 
// If checkMd5 is true then it will calculate the md5sum of the file
// as it is being received and check it against that returned from the
// server.  If it is wrong then it will return ObjectCorrupted
func (c *Connection) GetObject(container string, objectName string, contents io.Writer, checkMd5 bool, h Headers) (headers Headers, err error) {
	// FIXME content-type
	var resp *http.Response
	resp, headers, err = c.storage(storageParams{
		container:   container,
		object_name: objectName,
		operation:   "GET",
		errorMap:    objectErrorMap,
		headers:     h,
	})
	if err != nil {
		return
	}
	defer checkClose(resp.Body, &err)
	hash := md5.New()
	var body io.Writer = contents
	if checkMd5 {
		body = io.MultiWriter(contents, hash)
	}
	var written int64
	written, err = io.Copy(body, resp.Body)
	if err != nil {
		return
	}

	// Check the MD5 sum if requested
	if checkMd5 {
		md5 := strings.ToLower(resp.Header.Get("Etag"))
		body_md5 := fmt.Sprintf("%x", hash.Sum(nil))
		if md5 != body_md5 {
			err = ObjectCorrupted
			return
		}
	}

	// Check to see we wrote the correct number of bytes
	if resp.Header.Get("Content-Length") != "" {
		var object_length int64
		object_length, err = getInt64FromHeader(resp, "Content-Length")
		if err != nil {
			return
		}
		if object_length != written {
			err = ObjectCorrupted
			return
		}
	}

	return
}

// Return an object as a []byte
// This is a simplified interface which checks the MD5
func (c *Connection) GetObjectBytes(container string, objectName string) (contents []byte, err error) {
	var buf bytes.Buffer
	_, err = c.GetObject(container, objectName, &buf, true, nil)
	contents = buf.Bytes()
	return
}

// Return an object as a string
// This is a simplified interface which checks the MD5
func (c *Connection) GetObjectString(container string, objectName string) (contents string, err error) {
	var buf bytes.Buffer
	_, err = c.GetObject(container, objectName, &buf, true, nil)
	contents = buf.String()
	return
}

// Delete the object. May return ObjectDoesNotExist if the object isn't found
func (c *Connection) DeleteObject(container string, objectName string) (Headers, error) {
	_, headers, err := c.storage(storageParams{
		container:   container,
		object_name: objectName,
		operation:   "DELETE",
		errorMap:    objectErrorMap,
	})
	return headers, err
}
